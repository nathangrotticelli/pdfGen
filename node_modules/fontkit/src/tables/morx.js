// Generated by CoffeeScript 1.8.0
(function() {
  var BinarySearchHeader, ContextualEntry, ContextualStateHeader, Entry, FeatureEntry, IndicEntry, IndicStateHeader, InsertionStateEntry, InsertionStateHeader, LookupSegmentArray, LookupSegmentSingle, LookupSingle, LookupTable, MorxChain, StateArray, StateHeader, SubstitutionTable, Subtable, SubtableData, UnboundedArray, r,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  r = require('restructure');

  UnboundedArray = (function(_super) {
    var UnboundedArrayAccessor;

    __extends(UnboundedArray, _super);

    function UnboundedArray(type) {
      this.type = type;
      this.length = 0;
    }

    UnboundedArrayAccessor = (function() {
      function UnboundedArrayAccessor(type, stream, parent) {
        this.type = type;
        this.stream = stream;
        this.parent = parent;
        this.base = this.stream.pos;
        this._items = [];
      }

      UnboundedArrayAccessor.prototype.getItem = function(index) {
        var pos;
        if (this._items[index] == null) {
          pos = this.stream.pos;
          this.stream.pos = this.base + this.type.size(null, this.parent) * index;
          this._items[index] = this.type.decode(this.stream, this.parent);
          this.stream.pos = pos;
        }
        return this._items[index];
      };

      UnboundedArrayAccessor.prototype.inspect = function() {
        return "[UnboundedArray " + this.type.constructor.name + "]";
      };

      return UnboundedArrayAccessor;

    })();

    UnboundedArray.prototype.decode = function(stream, parent) {
      return new UnboundedArrayAccessor(this.type, stream, parent);
    };

    return UnboundedArray;

  })(r.Array);

  BinarySearchHeader = new r.Struct({
    unitSize: r.uint16,
    nUnits: r.uint16,
    searchRange: r.uint16,
    entrySelector: r.uint16,
    rangeShift: r.uint16
  });

  LookupSegmentSingle = new r.Struct({
    lastGlyph: r.uint16,
    firstGlyph: r.uint16,
    value: r.uint16
  });

  LookupSegmentArray = new r.Struct({
    lastGlyph: r.uint16,
    firstGlyph: r.uint16,
    values: new r.Pointer(r.uint16, new r.Array(r.uint16, function() {
      return this.lastGlyph - this.firstGlyph + 1;
    }), {
      type: 'parent'
    })
  });

  LookupSingle = new r.Struct({
    glyph: r.uint16,
    value: r.uint16
  });

  LookupTable = new r.VersionedStruct(r.uint16, {
    0: {
      values: new UnboundedArray(r.uint16)
    },
    2: {
      binarySearchHeader: BinarySearchHeader,
      segments: new r.Array(LookupSegmentSingle, function() {
        return this.binarySearchHeader.nUnits;
      })
    },
    4: {
      binarySearchHeader: BinarySearchHeader,
      segments: new r.Array(LookupSegmentArray, function() {
        return this.binarySearchHeader.nUnits;
      })
    },
    6: {
      binarySearchHeader: BinarySearchHeader,
      segments: new r.Array(LookupSingle, function() {
        return this.binarySearchHeader.nUnits;
      })
    },
    8: {
      firstGlyph: r.uint16,
      count: r.uint16,
      values: new r.Array(r.uint16, 'count')
    }
  });

  StateArray = new UnboundedArray(new r.Array(r.uint16, function() {
    return this.nClasses;
  }));

  Entry = new r.Struct({
    newState: r.uint16,
    flags: r.uint16,
    action: r.uint16
  });

  ContextualEntry = new r.Struct({
    newState: r.uint16,
    flags: r.uint16,
    markIndex: r.uint16,
    currentIndex: r.uint16
  });

  IndicEntry = new r.Struct({
    newState: r.uint16,
    flags: r.uint16
  });

  InsertionStateEntry = new r.Struct({
    newState: r.uint16,
    flags: r.uint16,
    currentInsertIndex: r.uint16,
    markedInsertIndex: r.uint16
  });

  StateHeader = new r.Struct({
    nClasses: r.uint32,
    classTable: new r.Pointer(r.uint32, LookupTable),
    stateArray: new r.Pointer(r.uint32, StateArray),
    entryTable: new r.Pointer(r.uint32, new UnboundedArray(Entry))
  });

  IndicStateHeader = new r.Struct({
    nClasses: r.uint32,
    classTable: new r.Pointer(r.uint32, LookupTable),
    stateArray: new r.Pointer(r.uint32, StateArray),
    entryTable: new r.Pointer(r.uint32, new UnboundedArray(IndicEntry))
  });

  ContextualStateHeader = new r.Struct({
    nClasses: r.uint32,
    classTable: new r.Pointer(r.uint32, LookupTable),
    stateArray: new r.Pointer(r.uint32, StateArray),
    entryTable: new r.Pointer(r.uint32, new UnboundedArray(ContextualEntry))
  });

  InsertionStateHeader = new r.Struct({
    nClasses: r.uint32,
    classTable: new r.Pointer(r.uint32, LookupTable),
    stateArray: new r.Pointer(r.uint32, StateArray),
    entryTable: new r.Pointer(r.uint32, new UnboundedArray(InsertionStateEntry))
  });

  SubstitutionTable = new r.Struct({
    items: new UnboundedArray(new r.Pointer(r.uint32, LookupTable))
  });

  SubtableData = new r.VersionedStruct('type', {
    0: {
      stateTable: IndicStateHeader
    },
    1: {
      stateTable: ContextualStateHeader,
      substitutionTable: new r.Pointer(r.uint32, SubstitutionTable)
    },
    2: {
      stateTable: StateHeader,
      ligatureActions: new r.Pointer(r.uint32, new UnboundedArray(r.uint32)),
      components: new r.Pointer(r.uint32, new UnboundedArray(r.uint16)),
      ligatureList: new r.Pointer(r.uint32, new UnboundedArray(r.uint16))
    },
    4: {
      lookupTable: LookupTable
    },
    5: {
      stateTable: InsertionStateHeader,
      insertionActions: new r.Pointer(r.uint32, new UnboundedArray(r.uint16))
    }
  });

  Subtable = new r.Struct({
    length: r.uint32,
    coverage: r.uint24,
    type: r.uint8,
    subFeatureFlags: r.uint32,
    table: SubtableData,
    padding: new r.Reserved(r.uint8, function() {
      return this.length - this._currentOffset;
    })
  });

  FeatureEntry = new r.Struct({
    featureType: r.uint16,
    featureSetting: r.uint16,
    enableFlags: r.uint32,
    disableFlags: r.uint32
  });

  MorxChain = new r.Struct({
    defaultFlags: r.uint32,
    chainLength: r.uint32,
    nFeatureEntries: r.uint32,
    nSubtables: r.uint32,
    features: new r.Array(FeatureEntry, 'nFeatureEntries'),
    subtables: new r.Array(Subtable, 'nSubtables')
  });

  module.exports = new r.Struct({
    version: r.uint16,
    unused: new r.Reserved(r.uint16),
    nChains: r.uint32,
    chains: new r.Array(MorxChain, 'nChains')
  });

}).call(this);
