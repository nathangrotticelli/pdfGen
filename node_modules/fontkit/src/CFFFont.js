// Generated by CoffeeScript 1.8.0
(function() {
  var CFFFont, CFFIndex, CFFPrivateDict, CFFTop, r, standardStrings;

  r = require('restructure');

  CFFIndex = require('./cff/CFFIndex');

  CFFTop = require('./cff/CFFTop');

  CFFPrivateDict = require('./cff/CFFPrivateDict');

  standardStrings = require('./cff/CFFStandardStrings');

  CFFFont = (function() {
    var get;

    function CFFFont(stream) {
      this.stream = stream;
      this.decode();
    }

    CFFFont.decode = function(stream) {
      return new CFFFont(stream);
    };

    CFFFont.open = function(filename, name) {
      var contents;
      contents = typeof require === "function" ? require('fs').readFileSync(filename) : void 0;
      return new CFFFont(new r.DecodeStream(contents));
    };

    CFFFont.prototype.decode = function() {
      var key, start, top, val;
      start = this.stream.pos;
      top = CFFTop.decode(this.stream);
      for (key in top) {
        val = top[key];
        this[key] = val;
      }
      if (this.topDictIndex.length !== 1) {
        throw new Error("Only a single font is allowed in CFF");
      }
      this.isCIDFont = this.topDict.ROS != null;
      switch (this.topDictIndex[0].Encoding) {
        case 0:
          break;
        case 1:
          break;
        default:
          break;
      }
      return this;
    };

    get = function(key, fn) {
      return Object.defineProperty(CFFFont.prototype, key, {
        get: fn,
        enumerable: true
      });
    };

    CFFFont.prototype.string = function(sid) {
      if (sid <= standardStrings.length) {
        return standardStrings[sid];
      }
      return this.stringIndex[sid - standardStrings.length];
    };

    get('topDict', function() {
      return this.topDictIndex[0];
    });

    get('postscriptName', function() {
      return this.nameIndex[0];
    });

    get('fullName', function() {
      return this.string(this.topDict.FullName);
    });

    get('familyName', function() {
      return this.string(this.topDict.FamilyName);
    });

    CFFFont.prototype.getCharString = function(glyph) {
      this.stream.pos = this.topDict.CharStrings[glyph].offset;
      return this.stream.readBuffer(this.topDict.CharStrings[glyph].length);
    };

    CFFFont.prototype.fdForGlyph = function(gid) {
      var high, low, mid, ranges, _ref;
      if (!this.topDict.FDSelect) {
        return null;
      }
      switch (this.topDict.FDSelect.version) {
        case 0:
          return this.topDict.FDSelect.fds[gid];
        case 3:
          ranges = this.topDict.FDSelect.ranges;
          low = 0;
          high = ranges.length - 1;
          while (low <= high) {
            mid = (low + high) >> 1;
            if (gid < ranges[mid].first) {
              high = mid - 1;
            } else if (gid > ((_ref = ranges[mid + 1]) != null ? _ref.first : void 0)) {
              low = mid + 1;
            } else {
              return ranges[mid].fd;
            }
          }
          break;
        default:
          throw new Error("Unknown FDSelect version: " + this.topDict.FDSelect.version);
      }
    };

    CFFFont.prototype.privateDictForGlyph = function(gid) {
      var fd, _ref;
      if (this.topDict.FDSelect) {
        fd = this.fdForGlyph(gid);
        if (fd != null) {
          return (_ref = this.topDict.FDArray[fd]) != null ? _ref.Private : void 0;
        } else {
          return null;
        }
      }
      return this.topDict.Private;
    };

    return CFFFont;

  })();

  module.exports = CFFFont;

}).call(this);
