// Generated by CoffeeScript 1.8.0
(function() {
  var DFont, TTFFont, r;

  r = require('restructure');

  TTFFont = require('./TTFFont');

  DFont = (function() {
    var DFontData, DFontHeader, DFontMap, DFontName, Ref, Type, TypeList;

    DFontName = new r.String(r.uint8);

    DFontData = new r.Struct({
      len: r.uint32,
      buf: new r.Buffer('len')
    });

    Ref = new r.Struct({
      id: r.uint16,
      nameOffset: r.int16,
      attr: r.uint8,
      dataOffset: r.uint24,
      handle: r.uint32
    });

    Type = new r.Struct({
      name: new r.String(4),
      maxTypeIndex: r.uint16,
      refList: new r.Pointer(r.uint16, new r.Array(Ref, function() {
        return this.maxTypeIndex + 1;
      }), {
        type: 'parent'
      })
    });

    TypeList = new r.Struct({
      length: r.uint16,
      types: new r.Array(Type, function() {
        return this.length + 1;
      })
    });

    DFontMap = new r.Struct({
      reserved: new r.Reserved(r.uint8, 24),
      typeList: new r.Pointer(r.uint16, TypeList),
      nameListOffset: new r.Pointer(r.uint16, 'void')
    });

    DFontHeader = new r.Struct({
      dataOffset: r.uint32,
      map: new r.Pointer(r.uint32, DFontMap),
      dataLength: r.uint32,
      mapLength: r.uint32
    });

    DFont.isDFont = function(stream) {
      var e, header, pos, type, _i, _len, _ref;
      pos = stream.pos;
      try {
        header = DFontHeader.decode(stream);
      } catch (_error) {
        e = _error;
        return false;
      } finally {
        stream.pos = pos;
      }
      _ref = header.map.typeList.types;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        if (type.name === 'sfnt') {
          return true;
        }
      }
      return false;
    };

    function DFont(stream) {
      var ref, type, _i, _j, _len, _len1, _ref, _ref1;
      this.stream = stream;
      this.header = DFontHeader.decode(this.stream);
      _ref = this.header.map.typeList.types;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        _ref1 = type.refList;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          ref = _ref1[_j];
          if (ref.nameOffset >= 0) {
            this.stream.pos = ref.nameOffset + this.header.map.nameListOffset;
            ref.name = DFontName.decode(this.stream);
          } else {
            ref.name = null;
          }
        }
        if (type.name === 'sfnt') {
          this.sfnt = type;
        }
      }
      return;
    }

    DFont.prototype.getFont = function(name) {
      var ref, substream, _i, _len, _ref;
      if (!this.sfnt) {
        return null;
      }
      _ref = this.sfnt.refList;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ref = _ref[_i];
        if (ref.name === name) {
          substream = new r.DecodeStream(this.stream.buffer);
          substream.pos = this.header.dataOffset + ref.dataOffset + 4;
          return new TTFFont(substream);
        }
      }
      return null;
    };

    return DFont;

  })();

  module.exports = DFont;

}).call(this);
