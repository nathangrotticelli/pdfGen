// Generated by CoffeeScript 1.8.0
(function() {
  var AATFeatureMap, AATMorxProcessor, CFFGlyph, CFFSubset, COLRGlyph, CmapProcessor, Directory, GPOSProcessor, GSUBProcessor, KernProcessor, SBIXGlyph, TTFFont, TTFGlyph, TTFSubset, r, tables,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  r = require('restructure');

  Directory = require('./tables/directory');

  tables = require('./tables');

  CmapProcessor = require('./CmapProcessor');

  GSUBProcessor = require('./opentype/GSUBProcessor');

  GPOSProcessor = require('./opentype/GPOSProcessor');

  AATFeatureMap = require('./aat/AATFeatureMap');

  AATMorxProcessor = require('./aat/AATMorxProcessor');

  KernProcessor = require('./KernProcessor');

  TTFGlyph = require('./glyph/TTFGlyph');

  CFFGlyph = require('./glyph/CFFGlyph');

  SBIXGlyph = require('./glyph/SBIXGlyph');

  COLRGlyph = require('./glyph/COLRGlyph');

  TTFSubset = require('./subset/TTFSubset');

  CFFSubset = require('./subset/CFFSubset');

  TTFFont = (function() {
    var codePointAt, get, getTable;

    function TTFFont(stream) {
      var table, tag, _ref;
      this.stream = stream;
      this._glyphs = {};
      this._decodeDirectory();
      _ref = this.directory.tables;
      for (tag in _ref) {
        table = _ref[tag];
        if (tables[tag]) {
          Object.defineProperty(this, tag, {
            get: getTable.bind(this, table)
          });
        }
      }
      return;
    }

    get = function(key, fn) {
      return Object.defineProperty(TTFFont.prototype, key, {
        get: fn,
        enumerable: true
      });
    };

    getTable = function(table) {
      var key, pos;
      key = '_' + table.tag;
      if (!(key in this)) {
        pos = this.stream.pos;
        this.stream.pos = table.offset;
        this[key] = this._decodeTable(table);
        this.stream.pos = pos;
      }
      return this[key];
    };

    TTFFont.prototype._getTableStream = function(tag) {
      var table;
      table = this.directory.tables[tag];
      if (table) {
        this.stream.pos = table.offset;
        return this.stream;
      }
      return null;
    };

    TTFFont.prototype._decodeDirectory = function() {
      return this.directory = Directory.decode(this.stream, {
        _startOffset: 0
      });
    };

    TTFFont.prototype._decodeTable = function(table) {
      return tables[table.tag].decode(this.stream, this, table.length);
    };

    get('postscriptName', function() {
      var lang, name;
      name = this.name.records.postscriptName;
      lang = Object.keys(name)[0];
      return name[lang];
    });

    get('fullName', function() {
      var _ref;
      return (_ref = this.name.records.fullName) != null ? _ref.English : void 0;
    });

    get('familyName', function() {
      var _ref;
      return (_ref = this.name.records.fontFamily) != null ? _ref.English : void 0;
    });

    get('subfamilyName', function() {
      var _ref;
      return (_ref = this.name.records.fontSubfamily) != null ? _ref.English : void 0;
    });

    get('copyright', function() {
      var _ref;
      return (_ref = this.name.records.copyright) != null ? _ref.English : void 0;
    });

    get('version', function() {
      var _ref;
      return (_ref = this.name.records.version) != null ? _ref.English : void 0;
    });

    get('scale', function() {
      return 1000 / this.head.unitsPerEm;
    });

    get('ascent', function() {
      return this.hhea.ascent * this.scale;
    });

    get('descent', function() {
      return this.hhea.descent * this.scale;
    });

    get('lineGap', function() {
      return this.hhea.lineGap * this.scale;
    });

    get('underlinePosition', function() {
      return this.post.underlinePosition * this.scale;
    });

    get('underlineThickness', function() {
      return this.post.underlineThickness * this.scale;
    });

    get('italicAngle', function() {
      return this.post.italicAngle / 65536;
    });

    get('capHeight', function() {
      var _ref;
      return ((_ref = this['OS/2']) != null ? _ref.capHeight : void 0) * this.scale || this.ascent;
    });

    get('xHeight', function() {
      var _ref;
      return ((_ref = this['OS/2']) != null ? _ref.xHeight : void 0) * this.scale || 0;
    });

    get('numGlyphs', function() {
      return this.maxp.numGlyphs;
    });

    get('unitsPerEm', function() {
      return this.head.unitsPerEm;
    });

    get('bbox', function() {
      return [this.head.xMin * this.scale, this.head.yMin * this.scale, this.head.xMax * this.scale, this.head.yMax * this.scale];
    });

    get('characterSet', function() {
      if (this._cmapProcessor == null) {
        this._cmapProcessor = new CmapProcessor(this.cmap);
      }
      return this._cmapProcessor.getCharacterSet();
    });

    TTFFont.prototype.hasGlyphForCodePoint = function(codePoint) {
      if (this._cmapProcessor == null) {
        this._cmapProcessor = new CmapProcessor(this.cmap);
      }
      return !!this._cmapProcessor.lookup(codePoint);
    };

    TTFFont.prototype.glyphForCodePoint = function(codePoint) {
      if (this._cmapProcessor == null) {
        this._cmapProcessor = new CmapProcessor(this.cmap);
      }
      return this.getGlyph(this._cmapProcessor.lookup(codePoint), [codePoint]);
    };

    codePointAt = function(str, idx) {
      var code, next;
      if (idx == null) {
        idx = 0;
      }
      code = str.charCodeAt(idx);
      next = str.charCodeAt(idx + 1);
      if ((0xd800 <= code && code <= 0xdbff) && (0xdc00 <= next && next <= 0xdfff)) {
        return ((code - 0xd800) * 0x400) + (next - 0xdc00) + 0x10000;
      }
      return code;
    };

    TTFFont.prototype.glyphsForString = function(str, userFeatures) {
      var glyphs, i, _i, _ref, _ref1;
      glyphs = [];
      for (i = _i = 0, _ref = str.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if ((0xdc00 <= (_ref1 = str.charCodeAt(i)) && _ref1 <= 0xdfff)) {
          continue;
        }
        glyphs.push(this.glyphForCodePoint(codePointAt(str, i)));
      }
      if ((userFeatures != null ? userFeatures.length : void 0) === 0) {
        return glyphs;
      }
      if (userFeatures == null) {
        userFeatures = ['ccmp', 'liga', 'rlig', 'clig', 'calt'];
      }
      if (userFeatures.length > 0 && this.GSUB) {
        if (this._GSUBProcessor == null) {
          this._GSUBProcessor = new GSUBProcessor(this, this.GSUB);
        }
        this._GSUBProcessor.applyFeatures(userFeatures, glyphs);
      } else if (this.morx) {
        if (this._morxProcessor == null) {
          this._morxProcessor = new AATMorxProcessor(this);
        }
        this._morxProcessor.process(glyphs, AATFeatureMap.mapOTToAAT(userFeatures));
      }
      return glyphs;
    };

    get('availableFeatures', function() {
      var aatFeatures, features, t;
      features = [];
      t = this.directory.tables;
      if (t.GSUB != null) {
        if (this._GSUBProcessor == null) {
          this._GSUBProcessor = new GSUBProcessor(this, this.GSUB);
        }
        features.push.apply(features, Object.keys(this._GSUBProcessor.features));
      }
      if (t.GPOS != null) {
        if (this._GPOSProcessor == null) {
          this._GPOSProcessor = new GPOSProcessor(this, this.GPOS);
        }
        features.push.apply(features, Object.keys(this._GPOSProcessor.features));
      }
      if (t.morx != null) {
        if (this._morxProcessor == null) {
          this._morxProcessor = new AATMorxProcessor(this);
        }
        aatFeatures = AATFeatureMap.mapAATToOT(this._morxProcessor.getSupportedFeatures());
        features.push.apply(features, aatFeatures);
      }
      if ((t.kern != null) && (!t.GPOS || !('kern' in this.GPOS.features))) {
        features.push('kern');
      }
      return features;
    });

    TTFFont.prototype.widthOfGlyph = function(glyph) {
      if (glyph < this.hmtx.metrics.length) {
        return this.hmtx.metrics[glyph].advanceWidth * this.scale;
      }
      return this.hmtx.metrics[this.hmtx.metrics.length - 1].advanceWidth * this.scale;
    };

    TTFFont.prototype.advancesForGlyphs = function(glyphs, userFeatures) {
      var advances, glyph, x, _i, _len;
      x = 0;
      advances = [];
      for (_i = 0, _len = glyphs.length; _i < _len; _i++) {
        glyph = glyphs[_i];
        advances.push(this.widthOfGlyph(glyph.id));
      }
      if ((userFeatures != null ? userFeatures.length : void 0) === 0) {
        return advances;
      }
      if (userFeatures == null) {
        userFeatures = ['kern'];
      }
      if (this.GPOS != null) {
        if (this._GPOSProcessor == null) {
          this._GPOSProcessor = new GPOSProcessor(this, this.GPOS);
        }
        this._GPOSProcessor.applyFeatures(userFeatures, glyphs, advances);
        if ('kern' in this._GPOSProcessor.features) {
          return advances;
        }
      }
      if (__indexOf.call(userFeatures, 'kern') >= 0 && (this.kern != null)) {
        if (this._kernProcessor == null) {
          this._kernProcessor = new KernProcessor(this);
        }
        this._kernProcessor.process(glyphs, advances);
      }
      return advances;
    };

    TTFFont.prototype.widthOfString = function(string, features) {
      var advance, advances, glyphs, width, _i, _len;
      glyphs = this.glyphsForString('' + string, features);
      advances = this.advancesForGlyphs(glyphs, features);
      width = 0;
      for (_i = 0, _len = advances.length; _i < _len; _i++) {
        advance = advances[_i];
        width += advance;
      }
      return width;
    };

    TTFFont.prototype._getBaseGlyph = function(glyph, characters) {
      if (characters == null) {
        characters = [];
      }
      if (!this._glyphs[glyph]) {
        if (this.directory.tables.glyf != null) {
          this._glyphs[glyph] = new TTFGlyph(glyph, characters, this);
        } else if (this.directory.tables['CFF '] != null) {
          this._glyphs[glyph] = new CFFGlyph(glyph, characters, this);
        }
      }
      return this._glyphs[glyph] || null;
    };

    TTFFont.prototype.getGlyph = function(glyph, characters) {
      if (characters == null) {
        characters = [];
      }
      if (!this._glyphs[glyph]) {
        if (this.directory.tables.sbix != null) {
          this._glyphs[glyph] = new SBIXGlyph(glyph, characters, this);
        } else if ((this.directory.tables.COLR != null) && (this.directory.tables.CPAL != null)) {
          this._glyphs[glyph] = new COLRGlyph(glyph, characters, this);
        } else {
          this._getBaseGlyph(glyph, characters);
        }
      }
      return this._glyphs[glyph] || null;
    };

    TTFFont.prototype.createSubset = function() {
      if (this.directory.tables['CFF '] != null) {
        return new CFFSubset(this);
      }
      return new TTFSubset(this);
    };

    return TTFFont;

  })();

  module.exports = TTFFont;

}).call(this);
