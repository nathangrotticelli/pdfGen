// Generated by CoffeeScript 1.8.0
(function() {
  var OpenTypeProcessor;

  OpenTypeProcessor = (function() {
    function OpenTypeProcessor(font, table) {
      this.font = font;
      this.table = table;
      this.script = null;
      this.scriptTag = null;
      this.language = null;
      this.languageTag = null;
      this.features = {};
      this.lookups = {};
      this.selectScript();
      this.glyphIndex = 0;
      this.glyphs = [];
      this.advances = [];
    }

    OpenTypeProcessor.prototype.findScript = function(script) {
      var entry, _i, _len, _ref;
      _ref = this.table.scriptList;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        entry = _ref[_i];
        if (entry.tag === script) {
          return entry;
        }
      }
      return null;
    };

    OpenTypeProcessor.prototype.selectScript = function(script, language) {
      var entry, featureIndex, lang, lookupIndex, lookups, record, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      if ((this.script == null) || script !== this.scriptTag) {
        if (script != null) {
          entry = this.findScript(script);
        }
        if (entry == null) {
          entry = this.findScript('DFLT');
        }
        if (entry == null) {
          entry = this.findScript('dflt');
        }
        if (entry == null) {
          entry = this.findScript('latn');
        }
        if (entry == null) {
          return;
        }
        this.scriptTag = entry.tag;
        this.script = entry.script;
      }
      if ((language != null) && language !== this.langugeTag) {
        _ref = this.script.langSysRecords;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          lang = _ref[_i];
          if (!(lang.tag === language)) {
            continue;
          }
          this.language = lang.langSys;
          break;
        }
      }
      if (this.language == null) {
        this.language = this.script.defaultLangSys;
      }
      this.features = {};
      this.lookups = {};
      _ref1 = this.language.featureIndexes;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        featureIndex = _ref1[_j];
        record = this.table.featureList[featureIndex];
        this.features[record.tag] = record.feature;
        lookups = [];
        _ref2 = record.feature.lookupListIndexes;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          lookupIndex = _ref2[_k];
          lookups.push(this.table.lookupList[lookupIndex]);
        }
        this.lookups[record.tag] = lookups;
      }
    };

    OpenTypeProcessor.prototype.applyFeatures = function(userFeatures, glyphs, advances) {
      var feature, lookup, table, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      this.glyphs = glyphs;
      this.advances = advances;
      this.glyphIndex = 0;
      while (this.glyphIndex < this.glyphs.length) {
        for (_i = 0, _len = userFeatures.length; _i < _len; _i++) {
          feature = userFeatures[_i];
          if (feature in this.lookups) {
            _ref = this.lookups[feature];
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              lookup = _ref[_j];
              _ref1 = lookup.subTables;
              for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                table = _ref1[_k];
                this.applyLookup(lookup.lookupType, table);
              }
            }
          }
        }
        this.glyphIndex++;
      }
    };

    OpenTypeProcessor.prototype.applyLookup = function(lookup, table) {
      throw new Error("applyLookup must be implemented by subclasses");
    };

    OpenTypeProcessor.prototype.applyLookupList = function(lookupRecords) {
      var glyphIndex, lookup, lookupRecord, table, _i, _j, _len, _len1, _ref;
      glyphIndex = this.glyphIndex;
      for (_i = 0, _len = lookupRecords.length; _i < _len; _i++) {
        lookupRecord = lookupRecords[_i];
        this.glyphIndex = glyphIndex + lookupRecord.sequenceIndex;
        lookup = this.table.lookupList[lookupRecord.lookupListIndex];
        _ref = lookup.subTables;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          table = _ref[_j];
          this.applyLookup(lookup.lookupType, table);
        }
      }
      this.glyphIndex = glyphIndex;
    };

    OpenTypeProcessor.prototype.coverageIndex = function(coverage, glyph) {
      var i, range, _i, _len, _ref;
      if (glyph == null) {
        glyph = this.glyphs[this.glyphIndex].id;
      }
      switch (coverage.version) {
        case 1:
          return coverage.glyphs.indexOf(glyph);
        case 2:
          _ref = coverage.rangeRecords;
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            range = _ref[i];
            if ((range.start <= glyph && glyph <= range.end)) {
              return range.startCoverageIndex + glyph - range.start;
            }
          }
      }
      return -1;
    };

    OpenTypeProcessor.prototype.sequenceMatches = function(sequenceIndex, sequence) {
      var component, glyphIndex, i, _i, _len;
      glyphIndex = this.glyphIndex + sequenceIndex;
      if (glyphIndex < 0 || glyphIndex + sequence.length > this.glyphs.length) {
        return false;
      }
      for (i = _i = 0, _len = sequence.length; _i < _len; i = ++_i) {
        component = sequence[i];
        if (component !== this.glyphs[glyphIndex + i].id) {
          return false;
        }
      }
      return true;
    };

    OpenTypeProcessor.prototype.coverageSequenceMatches = function(sequenceIndex, sequence) {
      var coverage, glyphIndex, i, _i, _len;
      glyphIndex = this.glyphIndex + sequenceIndex;
      if (glyphIndex < 0 || glyphIndex + sequence.length > this.glyphs.length) {
        return false;
      }
      for (i = _i = 0, _len = sequence.length; _i < _len; i = ++_i) {
        coverage = sequence[i];
        if (this.coverageIndex(coverage, this.glyphs[glyphIndex + i].id) === -1) {
          return false;
        }
      }
      return true;
    };

    OpenTypeProcessor.prototype.getClassID = function(sequenceIndex, classDef) {
      var classID, glyph, glyphID, range, _i, _j, _len, _len1, _ref, _ref1;
      glyph = this.glyphs[this.glyphIndex + sequenceIndex].id;
      switch (classDef.version) {
        case 1:
          glyphID = classDef.startGlyph;
          _ref = classDef.classValueArray;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            classID = _ref[_i];
            if (glyph === glyphID++) {
              return classID;
            }
          }
          break;
        case 2:
          _ref1 = classDef.classRangeRecord;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            range = _ref1[_j];
            if ((range.start <= glyph && glyph <= range.end)) {
              return range["class"];
            }
          }
      }
      return -1;
    };

    OpenTypeProcessor.prototype.classSequenceMatches = function(sequenceIndex, sequence, classDef) {
      var classID, glyphIndex, i, _i, _len;
      glyphIndex = this.glyphIndex + sequenceIndex;
      if (glyphIndex + sequence.length > this.glyphs.length) {
        return false;
      }
      for (i = _i = 0, _len = sequence.length; _i < _len; i = ++_i) {
        classID = sequence[i];
        if (classID !== this.getClassID(i, classDef)) {
          return false;
        }
      }
      return true;
    };

    return OpenTypeProcessor;

  })();

  module.exports = OpenTypeProcessor;

}).call(this);
