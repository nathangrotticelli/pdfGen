// Generated by CoffeeScript 1.8.0
(function() {
  var GSUBProcessor, OpenTypeProcessor,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  OpenTypeProcessor = require('./OpenTypeProcessor');

  GSUBProcessor = (function(_super) {
    __extends(GSUBProcessor, _super);

    function GSUBProcessor() {
      return GSUBProcessor.__super__.constructor.apply(this, arguments);
    }

    GSUBProcessor.prototype.applyLookup = function(lookupType, table) {
      var characters, glyph, index, ligature, rule, rules, set, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _results, _results1, _results2, _results3, _results4;
      switch (lookupType) {
        case 1:
          index = this.coverageIndex(table.coverage);
          if (index === -1) {
            return;
          }
          switch (table.version) {
            case 1:
              return this.glyphs[this.glyphIndex] = this.font.getGlyph(this.glyphs[this.glyphIndex].id + table.deltaGlyphID);
            case 2:
              return this.glyphs[this.glyphIndex] = this.font.getGlyph(table.substitute[index]);
          }
          break;
        case 2:
          index = this.coverageIndex(table.coverage);
          if (index !== -1) {
            return (_ref = this.glyphs).splice.apply(_ref, [this.glyphIndex, 1].concat(__slice.call(table.sequence[index])));
          }
          break;
        case 3:
          index = this.coverageIndex(table.coverage);
          if (index !== -1) {
            return this.glyphs[this.glyphIndex] = this.font.getGlyph(table.alternateSet[USER_INDEX]);
          }
          break;
        case 4:
          index = this.coverageIndex(table.coverage);
          if (index === -1) {
            return;
          }
          set = table.ligatureSets[index];
          _results = [];
          for (_i = 0, _len = set.length; _i < _len; _i++) {
            ligature = set[_i];
            if (!(this.sequenceMatches(1, ligature.components))) {
              continue;
            }
            characters = [];
            _ref1 = this.glyphs.slice(this.glyphIndex, this.glyphIndex + ligature.compCount);
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              glyph = _ref1[_j];
              characters.push.apply(characters, glyph.codePoints);
            }
            glyph = this.font.getGlyph(ligature.glyph, characters);
            this.glyphs.splice(this.glyphIndex, ligature.compCount, glyph);
            break;
          }
          return _results;
          break;
        case 5:
          switch (table.version) {
            case 1:
              index = this.coverageIndex(table.coverage);
              if (index === -1) {
                return;
              }
              set = table.subRuleSets[index];
              _results1 = [];
              for (_k = 0, _len2 = set.length; _k < _len2; _k++) {
                rule = set[_k];
                if (!(this.sequenceMatches(1, set.input))) {
                  continue;
                }
                this.applyLookupList(rule.lookupRecords);
                break;
              }
              return _results1;
              break;
            case 2:
              if (this.coverageIndex(table.coverage) === -1) {
                return;
              }
              index = this.getClassID(0, table.classDef);
              if (index === -1) {
                return;
              }
              set = table.subClassSet[index];
              _results2 = [];
              for (_l = 0, _len3 = set.length; _l < _len3; _l++) {
                rule = set[_l];
                if (!(this.classSequenceMatches(1, rule.classes, table.classDef))) {
                  continue;
                }
                this.applyLookupList(rule.lookupRecords);
                break;
              }
              return _results2;
              break;
            case 3:
              if (this.coverageSequenceMatches(0, table.coverages)) {
                return this.applyLookupList(table.substLookupRecord);
              }
          }
          break;
        case 6:
          switch (table.version) {
            case 1:
              index = this.coverageIndex(table.coverage);
              if (index === -1) {
                return;
              }
              set = table.chainSubRuleSets[index];
              _results3 = [];
              for (_m = 0, _len4 = set.length; _m < _len4; _m++) {
                rule = set[_m];
                if (this.sequenceMatches(-table.backtrack.length, table.backtrack) && this.sequenceMatches(1, table.input) && this.sequenceMatches(1 + table.input.length, table.lookahead)) {
                  this.applyLookupList(rule.lookupRecords);
                  break;
                } else {
                  _results3.push(void 0);
                }
              }
              return _results3;
              break;
            case 2:
              if (this.coverageIndex(table.coverage) === -1) {
                return;
              }
              index = getClassID(glyphs[glyphIndex], table.inputClassDef);
              if (index === -1) {
                return;
              }
              rules = table.chainSubClassSet[index];
              _results4 = [];
              for (_n = 0, _len5 = rules.length; _n < _len5; _n++) {
                rule = rules[_n];
                if (this.classSequenceMatches(-rule.backtrack.length, rule.backtrack, table.backtrackClassDef) && this.classSequenceMatches(1, rule.input, table.inputClassDef) && this.classSequenceMatches(1 + rule.input.length, rule.lookahead, table.lookaheadClassDef)) {
                  this.applyLookupList(rule.lookupRecords);
                  break;
                } else {
                  _results4.push(void 0);
                }
              }
              return _results4;
              break;
            case 3:
              if (this.coverageSequenceMatches(-table.backtrackGlyphCount, table.backtrackCoverage) && this.coverageSequenceMatches(0, table.inputCoverage) && this.coverageSequenceMatches(table.inputGlyphCount, table.lookaheadCoverage)) {
                return this.applyLookupList(table.substLookupRecord);
              }
          }
          break;
        case 7:
          return this.applyLookup(table.lookupType, table.extension);
        default:
          throw new Error("GSUB lookupType " + lookupType + " is not supported");
      }
    };

    return GSUBProcessor;

  })(OpenTypeProcessor);

  module.exports = GSUBProcessor;

}).call(this);
