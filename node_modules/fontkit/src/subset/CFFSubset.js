// Generated by CoffeeScript 1.8.0
(function() {
  var CFFPrivateDict, CFFSubset, CFFTop, Subset, standardStrings, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require('lodash');

  Subset = require('./Subset');

  CFFTop = require('../cff/CFFTop');

  CFFPrivateDict = require('../cff/CFFPrivateDict');

  standardStrings = require('../cff/CFFStandardStrings');

  CFFSubset = (function(_super) {
    __extends(CFFSubset, _super);

    function CFFSubset() {
      CFFSubset.__super__.constructor.apply(this, arguments);
      this.cff = this.font['CFF '];
      if (!this.cff) {
        throw new Error('Not a CFF Font');
      }
    }

    CFFSubset.prototype.subsetCharstrings = function() {
      var gid, glyph, gsubrs, path, subr, _i, _len, _ref;
      this.charstrings = [];
      gsubrs = {};
      _ref = this.glyphs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        gid = _ref[_i];
        this.charstrings.push(this.cff.getCharString(gid));
        glyph = this.font.getGlyph(gid);
        path = glyph.path;
        for (subr in glyph._usedGsubrs) {
          gsubrs[subr] = true;
        }
      }
      return this.gsubrs = this.subsetSubrs(this.cff.globalSubrIndex, gsubrs);
    };

    CFFSubset.prototype.subsetSubrs = function(subrs, used) {
      var i, res, subr, _i, _len;
      res = [];
      for (i = _i = 0, _len = subrs.length; _i < _len; i = ++_i) {
        subr = subrs[i];
        if (used[i]) {
          this.cff.stream.pos = subr.offset;
          res.push(this.cff.stream.readBuffer(subr.length));
        } else {
          res.push(new Buffer([11]));
        }
      }
      return res;
    };

    CFFSubset.prototype.subsetFontdict = function(topDict) {
      var dict, fd, gid, glyph, i, path, subr, used_fds, used_subrs, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      topDict.FDArray = [];
      topDict.FDSelect = {
        version: 0,
        fds: []
      };
      used_fds = {};
      used_subrs = [];
      _ref = this.glyphs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        gid = _ref[_i];
        fd = this.cff.fdForGlyph(gid);
        if (fd == null) {
          continue;
        }
        if (!used_fds[fd]) {
          topDict.FDArray.push(_.cloneDeep(this.cff.topDict.FDArray[fd]));
          used_subrs.push({});
        }
        used_fds[fd] = true;
        topDict.FDSelect.fds.push(topDict.FDArray.length - 1);
        glyph = this.font.getGlyph(gid);
        path = glyph.path;
        for (subr in glyph._usedSubrs) {
          used_subrs[used_subrs.length - 1][subr] = true;
        }
      }
      _ref1 = topDict.FDArray;
      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
        dict = _ref1[i];
        delete dict.FontName;
        if ((_ref2 = dict.Private) != null ? _ref2.Subrs : void 0) {
          dict.Private.Subrs = this.subsetSubrs(dict.Private.Subrs, used_subrs[i]);
        }
      }
    };

    CFFSubset.prototype.createCIDFontdict = function(topDict) {
      var gid, glyph, path, privateDict, subr, used_subrs, _i, _len, _ref;
      used_subrs = {};
      _ref = this.glyphs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        gid = _ref[_i];
        glyph = this.font.getGlyph(gid);
        path = glyph.path;
        for (subr in glyph._usedSubrs) {
          used_subrs[subr] = true;
        }
      }
      privateDict = _.cloneDeep(this.cff.topDict.Private);
      privateDict.Subrs = this.subsetSubrs(this.cff.topDict.Private.Subrs, used_subrs);
      topDict.FDArray = [
        {
          Private: privateDict
        }
      ];
      return topDict.FDSelect = {
        version: 3,
        nRanges: 1,
        ranges: [
          {
            first: 0,
            fd: 0
          }
        ],
        sentinel: this.charstrings.length
      };
    };

    CFFSubset.prototype.addString = function(string) {
      if (!string) {
        return null;
      }
      if (this.strings == null) {
        this.strings = [];
      }
      this.strings.push(string);
      return standardStrings.length + this.strings.length - 1;
    };

    CFFSubset.prototype.encode = function(stream) {
      var charset, key, top, topDict, _i, _len, _ref;
      this.subsetCharstrings();
      charset = {
        version: this.charstrings.length > 255 ? 2 : 1,
        ranges: [
          {
            first: 1,
            nLeft: this.charstrings.length - 2
          }
        ]
      };
      topDict = _.cloneDeep(this.cff.topDict);
      topDict.Private = null;
      topDict.charset = charset;
      topDict.Encoding = null;
      topDict.CharStrings = this.charstrings;
      _ref = ['version', 'Notice', 'Copyright', 'FullName', 'FamilyName', 'Weight', 'PostScript', 'BaseFontName', 'FontName'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        topDict[key] = this.addString(this.cff.string(topDict[key]));
      }
      topDict.ROS = [this.addString('Adobe'), this.addString('Identity'), 0];
      topDict.CIDCount = this.charstrings.length;
      if (this.cff.isCIDFont) {
        this.subsetFontdict(topDict);
      } else {
        this.createCIDFontdict(topDict);
      }
      top = {
        header: this.cff.header,
        nameIndex: [this.cff.postscriptName],
        topDictIndex: [topDict],
        stringIndex: this.strings,
        globalSubrIndex: this.gsubrs
      };
      return CFFTop.encode(stream, top);
    };

    return CFFSubset;

  })(Subset);

  module.exports = CFFSubset;

}).call(this);
