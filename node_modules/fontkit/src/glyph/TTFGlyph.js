// Generated by CoffeeScript 1.8.0
(function() {
  var Glyph, Path, TTFGlyph, r,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Glyph = require('./Glyph');

  Path = require('./Path');

  r = require('restructure');

  TTFGlyph = (function(_super) {
    var ARG_1_AND_2_ARE_WORDS, Component, GlyfHeader, MORE_COMPONENTS, ON_CURVE, Point, REPEAT, SAME_X, SAME_Y, WE_HAVE_AN_X_AND_Y_SCALE, WE_HAVE_A_SCALE, WE_HAVE_A_TWO_BY_TWO, WE_HAVE_INSTRUCTIONS, X_SHORT_VECTOR, Y_SHORT_VECTOR, parseGlyphCoord;

    __extends(TTFGlyph, _super);

    function TTFGlyph() {
      return TTFGlyph.__super__.constructor.apply(this, arguments);
    }

    GlyfHeader = new r.Struct({
      numberOfContours: r.int16,
      xMin: r.int16,
      yMin: r.int16,
      xMax: r.int16,
      yMax: r.int16
    });

    ON_CURVE = 1 << 0;

    X_SHORT_VECTOR = 1 << 1;

    Y_SHORT_VECTOR = 1 << 2;

    REPEAT = 1 << 3;

    SAME_X = 1 << 4;

    SAME_Y = 1 << 5;

    ARG_1_AND_2_ARE_WORDS = 1 << 0;

    WE_HAVE_A_SCALE = 1 << 3;

    MORE_COMPONENTS = 1 << 5;

    WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;

    WE_HAVE_A_TWO_BY_TWO = 1 << 7;

    WE_HAVE_INSTRUCTIONS = 1 << 8;

    Point = (function() {
      function Point(onCurve, endContour, x, y) {
        this.onCurve = onCurve;
        this.endContour = endContour;
        this.x = x != null ? x : 0;
        this.y = y != null ? y : 0;
      }

      return Point;

    })();

    Component = (function() {
      function Component(glyphID, dx, dy) {
        this.glyphID = glyphID;
        this.dx = dx;
        this.dy = dy;
        this.pos = 0;
        this.scale = this.xScale = this.yScale = this.scale01 = this.scale10 = null;
      }

      return Component;

    })();

    TTFGlyph.prototype._getCBox = function() {
      var glyph, stream;
      stream = this._font._getTableStream('glyf');
      stream.pos += this._font.loca.offsets[this.id];
      glyph = GlyfHeader.decode(stream);
      return [glyph.xMin, glyph.yMin, glyph.xMax, -glyph.yMax];
    };

    parseGlyphCoord = function(stream, prev, short, same) {
      var val;
      if (short) {
        val = stream.readUInt8();
        if (!same) {
          val = -val;
        }
        val += prev;
      } else {
        if (same) {
          val = prev;
        } else {
          val = prev + stream.readInt16BE();
        }
      }
      return val;
    };

    TTFGlyph.prototype._decode = function() {
      var glyph, startPos, stream;
      stream = this._font._getTableStream('glyf');
      stream.pos += this._font.loca.offsets[this.id];
      startPos = stream.pos;
      glyph = GlyfHeader.decode(stream);
      if (glyph.numberOfContours > 0) {
        this._decodeSimple(glyph, stream);
      } else if (glyph.numberOfContours < 0) {
        this._decodeComposite(glyph, stream, startPos);
      }
      return glyph;
    };

    TTFGlyph.prototype._decodeSimple = function(glyph, stream) {
      var count, endPtsOfContours, flag, flags, i, instructions, j, numCoords, point, px, py, _i, _j, _k, _l, _len, _len1, _len2;
      glyph.points = [];
      endPtsOfContours = new r.Array(r.uint16, glyph.numberOfContours).decode(stream);
      instructions = new r.Array(r.uint8, r.uint16).decode(stream);
      flags = [];
      numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;
      while (flags.length < numCoords) {
        flag = stream.readUInt8();
        flags.push(flag);
        if (flag & REPEAT) {
          count = stream.readUInt8();
          for (j = _i = 0; _i < count; j = _i += 1) {
            flags.push(flag);
          }
        }
      }
      for (i = _j = 0, _len = flags.length; _j < _len; i = ++_j) {
        flag = flags[i];
        point = new Point(!!(flag & ON_CURVE), endPtsOfContours.indexOf(i) >= 0, 0, 0);
        glyph.points.push(point);
      }
      px = 0;
      for (i = _k = 0, _len1 = flags.length; _k < _len1; i = ++_k) {
        flag = flags[i];
        glyph.points[i].x = px = parseGlyphCoord(stream, px, flag & X_SHORT_VECTOR, flag & SAME_X);
      }
      py = 0;
      for (i = _l = 0, _len2 = flags.length; _l < _len2; i = ++_l) {
        flag = flags[i];
        glyph.points[i].y = py = parseGlyphCoord(stream, py, flag & Y_SHORT_VECTOR, flag & SAME_Y);
      }
    };

    TTFGlyph.prototype._decodeComposite = function(glyph, stream, offset) {
      var component, dx, dy, flags, gPos, glyphID, haveInstructions;
      if (offset == null) {
        offset = 0;
      }
      glyph.components = [];
      haveInstructions = false;
      flags = MORE_COMPONENTS;
      while (flags & MORE_COMPONENTS) {
        flags = stream.readUInt16BE();
        gPos = stream.pos - offset;
        glyphID = stream.readUInt16BE();
        haveInstructions || (haveInstructions = (flags & WE_HAVE_INSTRUCTIONS) !== 0);
        if (flags & ARG_1_AND_2_ARE_WORDS) {
          dx = stream.readInt16BE();
          dy = stream.readInt16BE();
        } else {
          dx = stream.readInt8();
          dy = stream.readInt8();
        }
        component = new Component(glyphID, dx, dy);
        component.pos = gPos;
        component.scaleX = component.scaleY = 1;
        component.scale01 = component.scale10 = 0;
        if (flags & WE_HAVE_A_SCALE) {
          component.scaleX = component.scaleY = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;
        } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
          component.scaleX = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;
          component.scaleY = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;
        } else if (flags & WE_HAVE_A_TWO_BY_TWO) {
          component.scaleX = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;
          component.scale01 = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;
          component.scale10 = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;
          component.scaleY = ((stream.readUInt8() << 24) | (stream.readUInt8() << 16)) / 1073741824;
        }
        glyph.components.push(component);
      }
      return haveInstructions;
    };

    TTFGlyph.prototype._getContours = function() {
      var component, contours, cur, glyph, point, points, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      glyph = this._decode();
      if (glyph.numberOfContours < 0) {
        points = [];
        _ref = glyph.components;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          component = _ref[_i];
          glyph = this._font.getGlyph(component.glyphID)._decode();
          _ref1 = glyph.points;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            point = _ref1[_j];
            points.push(new Point(point.onCurve, point.endContour, point.x + component.dx, point.y + component.dy));
          }
        }
      } else {
        points = glyph.points;
      }
      contours = [];
      cur = [];
      for (_k = 0, _len2 = points.length; _k < _len2; _k++) {
        point = points[_k];
        cur.push(point);
        if (point.endContour) {
          contours.push(cur);
          cur = [];
        }
      }
      return contours;
    };

    TTFGlyph.prototype._getPath = function() {
      var contour, contours, curvePt, firstPt, j, lastPt, midX, midY, path, prevPt, pt, start, _i, _j, _len, _ref;
      contours = this._getContours();
      path = new Path;
      for (_i = 0, _len = contours.length; _i < _len; _i++) {
        contour = contours[_i];
        firstPt = contour[0];
        lastPt = contour[contour.length - 1];
        start = 0;
        if (firstPt.onCurve) {
          curvePt = null;
          start = 1;
        } else {
          if (lastPt.onCurve) {
            firstPt = lastPt;
          } else {
            firstPt = new Point(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);
          }
          curvePt = firstPt;
        }
        path.moveTo(firstPt.x, -firstPt.y);
        for (j = _j = start, _ref = contour.length; _j < _ref; j = _j += 1) {
          pt = contour[j];
          prevPt = j === 0 ? firstPt : contour[j - 1];
          if (prevPt.onCurve && pt.onCurve) {
            path.lineTo(pt.x, -pt.y);
          } else if (prevPt.onCurve && !pt.onCurve) {
            curvePt = pt;
          } else if (!prevPt.onCurve && !pt.onCurve) {
            midX = (prevPt.x + pt.x) / 2;
            midY = (prevPt.y + pt.y) / 2;
            path.quadraticCurveTo(prevPt.x, -prevPt.y, midX, -midY);
            curvePt = pt;
          } else if (!prevPt.onCurve && pt.onCurve) {
            path.quadraticCurveTo(curvePt.x, -curvePt.y, pt.x, -pt.y);
            curvePt = null;
          } else {
            throw new Error("Unknown TTF path state");
          }
        }
        if (firstPt !== lastPt) {
          if (curvePt) {
            path.quadraticCurveTo(curvePt.x, -curvePt.y, firstPt.x, -firstPt.y);
          } else {
            path.lineTo(firstPt.x, -firstPt.y);
          }
        }
      }
      path.closePath();
      return path;
    };

    return TTFGlyph;

  })(Glyph);

  module.exports = TTFGlyph;

}).call(this);
