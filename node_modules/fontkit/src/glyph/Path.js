// Generated by CoffeeScript 1.8.0
(function() {
  var Path,
    __slice = [].slice;

  Path = (function() {
    var BBox, SVG_COMMANDS, command, get, _fn, _i, _len, _ref;

    function Path() {
      this.commands = [];
      this._bbox = this._cbox = null;
    }

    _ref = ['moveTo', 'lineTo', 'quadraticCurveTo', 'bezierCurveTo', 'closePath'];
    _fn = function(command) {
      return Path.prototype[command] = function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        this._bbox = this._cbox = null;
        this.commands.push({
          command: command,
          args: args
        });
        return this;
      };
    };
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      command = _ref[_i];
      _fn(command);
    }

    Path.prototype.toFunction = function() {
      var c, cmds, _j, _len1, _ref1;
      cmds = [];
      _ref1 = this.commands;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        c = _ref1[_j];
        cmds.push("  ctx." + c.command + "(" + (c.args.join(', ')) + ");");
      }
      return new Function('ctx', cmds.join('\n'));
    };

    SVG_COMMANDS = {
      moveTo: 'M',
      lineTo: 'L',
      quadraticCurveTo: 'Q',
      bezierCurveTo: 'C',
      closePath: 'Z'
    };

    Path.prototype.toSVG = function() {
      var c, cmds, _j, _len1, _ref1;
      cmds = [];
      _ref1 = this.commands;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        c = _ref1[_j];
        cmds.push("" + SVG_COMMANDS[c.command] + (c.args.join(' ')));
      }
      return cmds.join('');
    };

    get = function(key, fn) {
      return Object.defineProperty(Path.prototype, key, {
        get: fn,
        enumerable: true
      });
    };

    BBox = (function() {
      function BBox() {
        this.minX = this.minY = Infinity;
        this.maxX = this.maxY = -Infinity;
      }

      BBox.prototype.addPoint = function(x, y) {
        if (x < this.minX) {
          this.minX = x;
        }
        if (y < this.minY) {
          this.minY = y;
        }
        if (x > this.maxX) {
          this.maxX = x;
        }
        if (y > this.maxY) {
          return this.maxY = y;
        }
      };

      BBox.prototype.toArray = function() {
        return [this.minX, this.minY, this.maxX, this.maxY];
      };

      return BBox;

    })();

    get('cbox', function() {
      var cbox, i, x, _j, _k, _len1, _len2, _ref1, _ref2;
      if (this._cbox) {
        return this._cbox;
      }
      cbox = new BBox;
      _ref1 = this.commands;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        command = _ref1[_j];
        _ref2 = command.args;
        for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = _k += 2) {
          x = _ref2[i];
          cbox.addPoint(x, command.args[i + 1]);
        }
      }
      return this._cbox = cbox.toArray();
    });

    get('bbox', function() {
      var a, b, b2ac, bbox, c, cp1x, cp1y, cp2x, cp2y, cx, cy, f, i, p0, p1, p2, p3, p3x, p3y, qp1x, qp1y, t, t1, t2, x, y, _j, _k, _len1, _ref1, _ref2, _ref3, _ref4;
      if (this._bbox) {
        return this._bbox;
      }
      bbox = new BBox;
      cx = cy = 0;
      f = function(t) {
        return Math.pow(1 - t, 3) * p0[i] + 3 * Math.pow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * Math.pow(t, 2) * p2[i] + Math.pow(t, 3) * p3[i];
      };
      _ref1 = this.commands;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        c = _ref1[_j];
        switch (c.command) {
          case 'moveTo':
          case 'lineTo':
            _ref2 = c.args, x = _ref2[0], y = _ref2[1];
            bbox.addPoint(x, y);
            cx = x;
            cy = y;
            break;
          case 'quadraticCurveTo':
          case 'bezierCurveTo':
            if (c.command === 'quadraticCurveTo') {
              _ref3 = c.args, qp1x = _ref3[0], qp1y = _ref3[1], p3x = _ref3[2], p3y = _ref3[3];
              cp1x = cx + 2 / 3 * (qp1x - cx);
              cp1y = cy + 2 / 3 * (qp1y - cy);
              cp2x = p3x + 2 / 3 * (qp1x - p3x);
              cp2y = p3y + 2 / 3 * (qp1y - p3y);
            } else {
              _ref4 = c.args, cp1x = _ref4[0], cp1y = _ref4[1], cp2x = _ref4[2], cp2y = _ref4[3], p3x = _ref4[4], p3y = _ref4[5];
            }
            bbox.addPoint(p3x, p3y);
            p0 = [cx, cy];
            p1 = [cp1x, cp1y];
            p2 = [cp2x, cp2y];
            p3 = [p3x, p3y];
            for (i = _k = 0; _k <= 1; i = ++_k) {
              b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
              a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
              c = 3 * p1[i] - 3 * p0[i];
              if (a === 0) {
                if (b === 0) {
                  continue;
                }
                t = -c / b;
                if (0 < t && t < 1) {
                  if (i === 0) {
                    bbox.addPoint(f(t), bbox.maxY);
                  }
                  if (i === 1) {
                    bbox.addPoint(bbox.maxX, f(t));
                  }
                }
                continue;
              }
              b2ac = Math.pow(b, 2) - 4 * c * a;
              if (b2ac < 0) {
                continue;
              }
              t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
              if (0 < t1 && t1 < 1) {
                if (i === 0) {
                  bbox.addPoint(f(t1), bbox.maxY);
                }
                if (i === 1) {
                  bbox.addPoint(bbox.maxX, f(t1));
                }
              }
              t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
              if (0 < t2 && t2 < 1) {
                if (i === 0) {
                  bbox.addPoint(f(t2), bbox.maxY);
                }
                if (i === 1) {
                  bbox.addPoint(bbox.maxX, f(t2));
                }
              }
            }
            cx = p3x;
            cy = p3y;
        }
      }
      return this._bbox = bbox.toArray();
    });

    return Path;

  })();

  module.exports = Path;

}).call(this);
