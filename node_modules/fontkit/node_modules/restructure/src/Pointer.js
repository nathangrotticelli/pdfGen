// Generated by CoffeeScript 1.7.1
(function() {
  var Pointer, VoidPointer;

  Pointer = (function() {
    function Pointer(offsetType, type, options) {
      var _base, _base1;
      this.offsetType = offsetType;
      this.type = type;
      this.options = options != null ? options : {};
      if (this.type === 'void') {
        this.type = null;
      }
      if ((_base = this.options).type == null) {
        _base.type = 'local';
      }
      if ((_base1 = this.options).allowNull == null) {
        _base1.allowNull = true;
      }
      if (this.options.relativeTo) {
        this.relativeToGetter = new Function('ctx', "return ctx." + this.options.relativeTo);
      }
    }

    Pointer.prototype.decode = function(stream, ctx) {
      var c, offset, pos, ptr, relative, res;
      offset = this.offsetType.decode(stream);
      pos = stream.pos;
      if (offset === 0 && this.options.allowNull) {
        return null;
      }
      relative = (function() {
        switch (this.options.type) {
          case 'local':
            return ctx._startOffset;
          case 'immediate':
            return stream.pos - this.offsetType.size();
          case 'parent':
            return ctx.parent._startOffset;
          default:
            c = ctx;
            while (c.parent) {
              c = c.parent;
            }
            return c._startOffset;
        }
      }).call(this);
      if (this.options.relativeTo) {
        relative += this.relativeToGetter(ctx);
      }
      ptr = offset + relative;
      if (this.type != null) {
        stream.pos = ptr;
        res = this.type.decode(stream, ctx);
        stream.pos = pos;
        return res;
      } else {
        return ptr;
      }
    };

    Pointer.prototype.size = function(val, ctx) {
      var parent, type;
      if (val == null) {
        return this.offsetType.size();
      }
      parent = ctx;
      switch (this.options.type) {
        case 'local':
        case 'immediate':
          break;
        case 'parent':
          ctx = ctx.parent;
          break;
        default:
          while (ctx.parent) {
            ctx = ctx.parent;
          }
      }
      type = this.type;
      if (type == null) {
        if (!(val instanceof VoidPointer)) {
          throw new Error("Must be a VoidPointer");
        }
        type = val.type;
        val = val.value;
      }
      if (ctx != null) {
        ctx.pointerSize += type.size(val, parent);
      }
      return this.offsetType.size();
    };

    Pointer.prototype.encode = function(stream, val, ctx) {
      var parent, relative, type;
      parent = ctx;
      if (val == null) {
        this.offsetType.encode(stream, 0);
        return;
      }
      switch (this.options.type) {
        case 'local':
          relative = ctx.startOffset;
          break;
        case 'immediate':
          relative = stream.pos + this.offsetType.size(val, parent);
          break;
        case 'parent':
          ctx = ctx.parent;
          relative = ctx.startOffset;
          break;
        default:
          relative = 0;
          while (ctx.parent) {
            ctx = ctx.parent;
          }
      }
      if (this.options.relativeTo) {
        relative += this.relativeToGetter(parent.val);
      }
      this.offsetType.encode(stream, ctx.pointerOffset - relative);
      type = this.type;
      if (type == null) {
        if (!(val instanceof VoidPointer)) {
          throw new Error("Must be a VoidPointer");
        }
        type = val.type;
        val = val.value;
      }
      ctx.pointers.push({
        type: type,
        val: val,
        parent: parent
      });
      return ctx.pointerOffset += type.size(val, parent);
    };

    return Pointer;

  })();

  VoidPointer = (function() {
    function VoidPointer(type, value) {
      this.type = type;
      this.value = value;
    }

    return VoidPointer;

  })();

  exports.Pointer = Pointer;

  exports.VoidPointer = VoidPointer;

}).call(this);
